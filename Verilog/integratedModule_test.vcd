$date
	Tue Nov 28 21:26:59 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module benchtest_IntegratedModule $end
$var wire 4 ! Cout [3:0] $end
$var wire 8 " Y_8bit [7:0] $end
$var wire 4 # Y [3:0] $end
$var reg 4 $ A [3:0] $end
$var reg 4 % B [3:0] $end
$var reg 1 & cin $end
$var reg 4 ' opcode [3:0] $end
$scope module uut $end
$var wire 4 ( A [3:0] $end
$var wire 4 ) B [3:0] $end
$var wire 1 & Cin $end
$var wire 4 * Cout [3:0] $end
$var wire 4 + opcode [3:0] $end
$var wire 4 , Y_xor [3:0] $end
$var wire 4 - Y_xnor [3:0] $end
$var wire 4 . Y_sub [3:0] $end
$var wire 4 / Y_shifter [3:0] $end
$var wire 4 0 Y_or [3:0] $end
$var wire 4 1 Y_not [3:0] $end
$var wire 4 2 Y_nor [3:0] $end
$var wire 4 3 Y_nand [3:0] $end
$var wire 8 4 Y_multi [7:0] $end
$var wire 4 5 Y_and [3:0] $end
$var wire 4 6 Y_add [3:0] $end
$var wire 8 7 Y_8bit [7:0] $end
$var wire 4 8 Y [3:0] $end
$scope module add_inst $end
$var wire 4 9 A [3:0] $end
$var wire 4 : B [3:0] $end
$var wire 1 & Cin $end
$var wire 4 ; Cout [3:0] $end
$var wire 4 < Sum [3:0] $end
$upscope $end
$scope module and_inst $end
$var wire 4 = A [3:0] $end
$var wire 4 > B [3:0] $end
$var wire 4 ? Y [3:0] $end
$upscope $end
$scope module multi_inst $end
$var wire 4 @ A [3:0] $end
$var wire 4 A B [3:0] $end
$var wire 8 B Product [7:0] $end
$var wire 8 C sum [7:0] $end
$scope begin gen_mult[0] $end
$upscope $end
$scope begin gen_mult[1] $end
$upscope $end
$scope begin gen_mult[2] $end
$upscope $end
$scope begin gen_mult[3] $end
$upscope $end
$upscope $end
$scope module nand_inst $end
$var wire 4 D A [3:0] $end
$var wire 4 E B [3:0] $end
$var wire 4 F Y [3:0] $end
$upscope $end
$scope module nor_inst $end
$var wire 4 G A [3:0] $end
$var wire 4 H B [3:0] $end
$var wire 4 I Y [3:0] $end
$upscope $end
$scope module not_inst $end
$var wire 4 J A [3:0] $end
$var wire 4 K Y [3:0] $end
$upscope $end
$scope module or_inst $end
$var wire 4 L A [3:0] $end
$var wire 4 M B [3:0] $end
$var wire 4 N Y [3:0] $end
$upscope $end
$scope module shifter_inst $end
$var wire 4 O A [3:0] $end
$var wire 4 P B [3:0] $end
$var wire 2 Q shift_amount [2:1] $end
$var wire 1 R shift $end
$var wire 1 S fill $end
$var wire 4 T Y [3:0] $end
$upscope $end
$scope module sub_inst $end
$var wire 4 U A [3:0] $end
$var wire 4 V B [3:0] $end
$var wire 1 & Cin $end
$var wire 4 W Cout [3:0] $end
$var wire 4 X Result [3:0] $end
$upscope $end
$scope module xnor_inst $end
$var wire 4 Y A [3:0] $end
$var wire 4 Z B [3:0] $end
$var wire 4 [ Y [3:0] $end
$upscope $end
$scope module xor_inst $end
$var wire 4 \ A [3:0] $end
$var wire 4 ] B [3:0] $end
$var wire 4 ^ Y [3:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b111 ^
b1011 ]
b1100 \
b1000 [
b1011 Z
b1100 Y
b0 X
b0x W
b1011 V
b1100 U
b1100 T
1S
1R
b1 Q
b1011 P
b1100 O
b1111 N
b1011 M
b1100 L
b11 K
b1100 J
b0 I
b1011 H
b1100 G
b111 F
b1011 E
b1100 D
b10000100 C
b10000100 B
b1011 A
b1100 @
b1000 ?
b1011 >
b1100 =
b1000 <
b0x ;
b1011 :
b1100 9
b1000 8
b0 7
b1000 6
b1000 5
b10000100 4
b111 3
b0 2
b11 1
b1111 0
b1100 /
b0 .
b1000 -
b111 ,
b0 +
b0x *
b1011 )
b1100 (
b0 '
1&
b1011 %
b1100 $
b1000 #
b0 "
b0x !
$end
#5
b1 /
b1 T
b1101 3
b1101 F
b10 -
b10 [
b1101 #
b1101 8
0R
b11 Q
0S
b1 6
b1 <
b10 5
b10 ?
b1000010 4
b1000010 B
b1000010 C
b100 1
b100 K
b101 .
b101 X
b1101 ,
b1101 ^
b11 '
b11 +
0&
b110 %
b110 )
b110 :
b110 >
b110 A
b110 E
b110 H
b110 M
b110 P
b110 V
b110 Z
b110 ]
b1011 $
b1011 (
b1011 9
b1011 =
b1011 @
b1011 D
b1011 G
b1011 J
b1011 L
b1011 O
b1011 U
b1011 Y
b1011 \
#10
b11 #
b11 8
b11 /
b11 T
b1000110 4
b1000110 B
b1000110 C
b1011 3
b1011 F
b100 -
b100 [
b10 Q
1S
b11 6
b11 <
b100 5
b100 ?
b1 1
b1 K
b1001 .
b1001 X
b1011 ,
b1011 ^
b111 '
b111 +
b101 %
b101 )
b101 :
b101 >
b101 A
b101 E
b101 H
b101 M
b101 P
b101 V
b101 Z
b101 ]
b1110 $
b1110 (
b1110 9
b1110 =
b1110 @
b1110 D
b1110 G
b1110 J
b1110 L
b1110 O
b1110 U
b1110 Y
b1110 \
#15
b1110 #
b1110 8
b1110 /
b1110 T
b110 3
b110 F
b10 2
b10 I
b1011 -
b1011 [
1R
b0 Q
b110 6
b110 <
b1001 5
b1001 ?
b1110101 4
b1110101 B
b1110101 C
b10 1
b10 K
b1101 0
b1101 N
b100 .
b100 X
b100 ,
b100 ^
b1010 '
b1010 +
b1001 %
b1001 )
b1001 :
b1001 >
b1001 A
b1001 E
b1001 H
b1001 M
b1001 P
b1001 V
b1001 Z
b1001 ]
b1101 $
b1101 (
b1101 9
b1101 =
b1101 @
b1101 D
b1101 G
b1101 J
b1101 L
b1101 O
b1101 U
b1101 Y
b1101 \
#20
b0 /
b0 T
b111 #
b111 8
b111 3
b111 F
b101 2
b101 I
b1101 -
b1101 [
b1 Q
0S
b11 6
b11 <
b1000 5
b1000 ?
b1010000 4
b1010000 B
b1010000 C
b111 1
b111 K
b1010 0
b1010 N
b1101 .
b1101 X
bx1 !
bx1 *
bx1 ;
bx1 W
b10 ,
b10 ^
b1 '
b1 +
1&
b1010 %
b1010 )
b1010 :
b1010 >
b1010 A
b1010 E
b1010 H
b1010 M
b1010 P
b1010 V
b1010 Z
b1010 ]
b1000 $
b1000 (
b1000 9
b1000 =
b1000 @
b1000 D
b1000 G
b1000 J
b1000 L
b1000 O
b1000 U
b1000 Y
b1000 \
#25
b1111 #
b1111 8
b1000110 4
b1000110 B
b1000110 C
b1011 3
b1011 F
b0 2
b0 I
b1000 /
b1000 T
b100 -
b100 [
b11 Q
b100 5
b100 ?
b1010 1
b1010 K
b1111 0
b1111 N
b111 .
b111 X
b1011 ,
b1011 ^
b10 '
b10 +
0&
b1110 %
b1110 )
b1110 :
b1110 >
b1110 A
b1110 E
b1110 H
b1110 M
b1110 P
b1110 V
b1110 Z
b1110 ]
b101 $
b101 (
b101 9
b101 =
b101 @
b101 D
b101 G
b101 J
b101 L
b101 O
b101 U
b101 Y
b101 \
#30
b100 #
b100 8
b1 /
b1 T
b1001110 4
b1001110 B
b1001110 C
0R
b0x !
b0x *
b0x ;
b0x W
b10 1
b10 K
b100 '
b100 +
b110 %
b110 )
b110 :
b110 >
b110 A
b110 E
b110 H
b110 M
b110 P
b110 V
b110 Z
b110 ]
b1101 $
b1101 (
b1101 9
b1101 =
b1101 @
b1101 D
b1101 G
b1101 J
b1101 L
b1101 O
b1101 U
b1101 Y
b1101 \
#35
b0 #
b0 8
b1000 /
b1000 T
b10010110 4
b10010110 B
b10010110 C
b101 3
b101 F
b1010 -
b1010 [
1R
1S
bx1 !
bx1 *
bx1 ;
bx1 W
b1001 6
b1001 <
b1010 5
b1010 ?
b101 1
b101 K
b1011 .
b1011 X
b101 ,
b101 ^
b101 '
b101 +
b1111 %
b1111 )
b1111 :
b1111 >
b1111 A
b1111 E
b1111 H
b1111 M
b1111 P
b1111 V
b1111 Z
b1111 ]
b1010 $
b1010 (
b1010 9
b1010 =
b1010 @
b1010 D
b1010 G
b1010 J
b1010 L
b1010 O
b1010 U
b1010 Y
b1010 \
#40
b1101 #
b1101 8
b10 /
b10 T
b1111 3
b1111 F
b1101 2
b1101 I
b1101 -
b1101 [
0R
b0 Q
0S
b0 !
b0 *
b0 ;
b0 W
b10 6
b10 <
b0 5
b0 ?
b0 4
b0 B
b0 C
b1101 1
b1101 K
b10 0
b10 N
b10 .
b10 X
b10 ,
b10 ^
b110 '
b110 +
b0 %
b0 )
b0 :
b0 >
b0 A
b0 E
b0 H
b0 M
b0 P
b0 V
b0 Z
b0 ]
b10 $
b10 (
b10 9
b10 =
b10 @
b10 D
b10 G
b10 J
b10 L
b10 O
b10 U
b10 Y
b10 \
#45
b110 #
b110 8
b110111 4
b110111 B
b110111 C
b1110 3
b1110 F
b0 2
b0 I
b1 /
b1 T
b1 -
b1 [
b0x !
b0x *
b0x ;
b0x W
b10 Q
1S
b0 6
b0 <
b1 5
b1 ?
b100 1
b100 K
b1111 0
b1111 N
b110 .
b110 X
b1110 ,
b1110 ^
b1000 '
b1000 +
b101 %
b101 )
b101 :
b101 >
b101 A
b101 E
b101 H
b101 M
b101 P
b101 V
b101 Z
b101 ]
b1011 $
b1011 (
b1011 9
b1011 =
b1011 @
b1011 D
b1011 G
b1011 J
b1011 L
b1011 O
b1011 U
b1011 Y
b1011 \
#50
b0 #
b0 8
b100 /
b100 T
b1111 3
b1111 F
b0 -
b0 [
b100100 "
b100100 7
b0 !
b0 *
b0 ;
b0 W
b1 Q
b1111 6
b1111 <
b0 5
b0 ?
b100100 4
b100100 B
b100100 C
b11 1
b11 K
b1001 .
b1001 X
b1111 ,
b1111 ^
b1001 '
b1001 +
b11 %
b11 )
b11 :
b11 >
b11 A
b11 E
b11 H
b11 M
b11 P
b11 V
b11 Z
b11 ]
b1100 $
b1100 (
b1100 9
b1100 =
b1100 @
b1100 D
b1100 G
b1100 J
b1100 L
b1100 O
b1100 U
b1100 Y
b1100 \
#55
